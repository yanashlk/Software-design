# Лабораторна робота №2
## Породжувальні шаблони
### TASK2
В цьому завданні ми визначили абстрактні класи для кожного типу технічного пристрою та абстрактну фабрику, 
яка реалізує методи створення кожного типу технічного пристрою. 
Кожна конкретна фабрика створює пристрої відповідного бренду. 
У головному методі програми ми демонструємо створення пристроїв за допомогою конкретних фабрик.
В коді метод DisplayInfo() визначений в класах, які наслідуються від абстрактних класів (Laptop, Netbook, EBook, Smartphone)
Конструктори класів LenovoLaptop, AsusNetbook, AmazonKindle, і GooglePixel ініціалізують поля об'єктів деякими значеннями. 
У головному методі програми, через фабрики створюються екземпляри класів, і потім викликається метод DisplayInfo(), щоб вивести інформацію про кожен пристрій.
### TASK3
У цьому завданні використовується клас Authenticator , який реалізує шаблон Singleton. 
Метод Instance повертає єдиний екземпляр класу, який створюється тільки при першому виклику. 
При кожному наступному виклику повертається той самий екземпляр.
Цей клас може створити лише один екземпляр завдяки використанню шаблону Singleton та конструкції подвійної перевірки (double-check). 
- Приватний конструктор: конструктор класу встановлений як приватний, що забороняє зовнішнім частинам створювати екземпляри класу напряму.
- Статичне поле instance та syncRoot: поле instance визначено як volatile, що забезпечує правильну роботу потоків при використанні подвійної перевірки. 
Поле syncRoot використовується як об'єкт блокування для забезпечення потокобезпечності при створенні єдиного екземпляра.
- Метод Instance: це властивість, яка слугує точкою доступу до єдиного екземпляра класу. 
У випадку, якщо екземпляр ще не створений (instance == null), блок lock забезпечує, що тільки один потік зможе зайти в цю частину коду.
Після входу у цей блок lock проводиться ще одна перевірка, щоб упевнитися, що екземпляр ще не створений, і тільки потім відбувається його створення.
- Подвійна перевірка (if (instance == null) в середині блоку lock): Це механізм, який дозволяє уникнути зайвого використання блокування у випадку, коли екземпляр вже створений. 
Якщо екземпляр вже існує, не потрібно використовувати блокування для кожного виклику.
Ці механізми взаємодіють, щоб забезпечити те, що тільки один екземпляр класу буде створений, і всі наступні виклики методу Instance повертатимуть цей єдиний екземпляр.
### TASK4
Тут використовується клас Virus, що реалізує інтерфейс ICloneable, щоб забезпечити можливість клонування об'єктів. 
Метод Clone використовується для створення глибокої копії об'єкту Virus та його дочірніх вірусів. 
Клас Program демонструє створення початкового вірусу, його клонування та модифікацію клонованого вірусу.
Механізм роботи прототипа виглядає так: клас Virus реалізує інтерфейс ICloneable, який містить метод клонування. 
Коли клієнтський код потребує нового вірусу, він просто клонує існуючий вірус за допомогою методу Clone. 
Коли вірус клонується, він повертає новий об'єкт, який має такі ж атрибути, як і вихідний вірус, але не є тим самим об'єктом.
### TASK5
Можемо побачити, як працює патерн "Будівельник" на прикладі створення персонажів (героя та ворога):
1. Спочатку створюється директор (CharacterDirector), який буде відповідати за побудову персонажів.
2. Потім створюється будівельник (HeroBuilder або EnemyBuilder), який буде використовуватися для побудови конкретного типу персонажа.
3. Клієнт (у цьому випадку Program.Main()) викликає методи будівельника для встановлення різних атрибутів персонажа.
4. Клієнт викликає метод ConstructCharacter() директора, який в свою чергу викликає методи будівельника для побудови персонажа.
5. Будівельник встановлює всі атрибути персонажа відповідно до вказівок директора.
6. Директор повертає готового персонажа клієнту.
7. Це дозволяє створювати різні типи персонажів з однаковим процесом побудови, але з різними наборами атрибутів.